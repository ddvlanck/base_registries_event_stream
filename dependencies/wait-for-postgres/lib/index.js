// Generated by CoffeeScript 1.12.7
(function() {
  var P, config, durations, getConnection, makeUri, pg, program, runScript, waitForPostgres;

  P = require('bluebird');

  pg = require('pg');

  program = require('commander');

  durations = require('durations');

  config = require('./config');

  getConnection = function(uri, connectTimeout) {
    var client;
    client = new pg.Client({
      connectionString: uri
    });
    return new P(function(resolve, reject) {
      return client.connect(function(error) {
        if (error != null) {
          return reject(error);
        } else {
          return resolve(client);
        }
      });
    }).timeout(connectTimeout)["catch"](function(error) {
      client.end();
      throw error;
    });
  };

  makeUri = function(cfg, pass) {
    var database, host, password, port, username;
    username = cfg.username, password = cfg.password, host = cfg.host, port = cfg.port, database = cfg.database;
    pass = pass != null ? pass : password;
    return "postgres://" + username + ":" + pass + "@" + host + ":" + port + "/" + database;
  };

  waitForPostgres = function(partialConfig) {
    return config.validate(partialConfig).then(function(cfg) {
      return new P(function(resolve) {
        var attempts, connectTimeout, connectWatch, database, host, masked, password, port, query, quiet, testConnection, totalTimeout, uri, username, watch;
        username = cfg.username, password = cfg.password, host = cfg.host, port = cfg.port, database = cfg.database, connectTimeout = cfg.connectTimeout, totalTimeout = cfg.totalTimeout, quiet = cfg.quiet, query = cfg.query;
        uri = makeUri(cfg);
        masked = makeUri(cfg, '***');
        console.log("URI: " + masked);
        watch = durations.stopwatch().start();
        connectWatch = durations.stopwatch();
        attempts = 0;
        testConnection = function() {
          attempts += 1;
          connectWatch.reset().start();
          return getConnection(uri, connectTimeout).then(function(client) {
            connectWatch.stop();
            if (query != null) {
              console.log("Connected. Running test query: '" + query + "'");
              return client.query(query, function(error, result) {
                var connectDelay, totalRemaining;
                console.log("Query done.");
                client.end();
                if (error) {
                  if (!quiet) {
                    console.log("[" + error + "] Attempt " + attempts + " query failure. Time elapsed: " + watch);
                  }
                  if (watch.duration().millis() > totalTimeout) {
                    if (!quiet) {
                      console.log("Postgres test query failed.");
                    }
                    return resolve(1);
                  } else {
                    totalRemaining = Math.min(connectTimeout, Math.max(0, totalTimeout - watch.duration().millis()));
                    connectDelay = Math.min(totalRemaining, Math.max(0, connectTimeout - connectWatch.duration().millis()));
                    return setTimeout(testConnection, connectDelay);
                  }
                } else {
                  watch.stop();
                  console.log("Query succeeded after " + attempts + " attempt(s) over " + watch);
                  return resolve(0);
                }
              });
            } else {
              watch.stop();
              console.log("Connected after " + attempts + " attempt(s) over " + watch);
              client.end();
              return resolve(0);
            }
          })["catch"](function(error) {
            var connectDelay, totalRemaining;
            connectWatch.stop();
            if (!quiet) {
              console.log("[" + error + "] Attempt " + attempts + " timed out. Time elapsed: " + watch);
            }
            if (watch.duration().millis() > totalTimeout) {
              if (!quiet) {
                console.log("Could not connect to Postgres.");
              }
              return resolve(1);
            } else {
              totalRemaining = Math.min(connectTimeout, Math.max(0, totalTimeout - watch.duration().millis()));
              connectDelay = Math.min(totalRemaining, Math.max(0, connectTimeout - connectWatch.duration().millis()));
              return setTimeout(testConnection, connectDelay);
            }
          });
        };
        return testConnection();
      });
    });
  };

  runScript = function() {
    var partialConfig;
    program.option('-D, --database <database>', 'Postgres database name (default is postgres)').option('-h, --host <host>', 'Postgres hostname (default is localhost)').option('-p, --port <port>', 'Postgres port (default is 5432)', parseInt).option('-P, --password <password>', 'Postgres user password (default is empty)').option('-q, --quiet', 'Silence non-error output (default is false)').option('-Q, --query <query_string>', 'Custom query to confirm database state').option('-t, --connect-timeout <connect-timeout>', 'Individual connection attempt timeout (default is 250)', parseInt).option('-T, --total-timeout <total-timeout>', 'Total timeout across all connect attempts (dfault is 15000)', parseInt).option('-u, --username <username>', 'Posgres user name (default is postgres)').parse(process.argv);
    partialConfig = {
      host: program.host,
      port: program.port,
      username: program.username,
      password: program.password,
      database: program.database,
      connectTimeout: program.connectTimeout,
      totalTimeout: program.totalTimeout,
      query: program.query,
      quiet: program.quiet
    };
    return waitForPostgres(partialConfig).then(function(code) {
      return process.exit(code);
    });
  };

  module.exports = {
    wait: waitForPostgres,
    run: runScript
  };

  if (require.main === module) {
    runScript();
  }

}).call(this);
